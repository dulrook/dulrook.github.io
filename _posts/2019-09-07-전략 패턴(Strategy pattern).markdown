---
layout: splash
title:  "전략 패턴(Strategy pattern)"
date:   2019-09-07 10:46:52 +0900
categories: 디자인패턴
---

# [전략 패턴]
## 의도(Intent)
동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화한다. 그리고 각 알고리즘을 상호 교환되게 한다. 알고리즘을 사용하는 클라이언트와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 한다.

## 다른 이름(Also Known As)
Policy

## 동기(Motivation)
텍스트의 줄을 바꿔주는(Line breaking) 알고리즘은 다양하다. 그러나 이 알고리즘들을 한 클래스에 하드코딩하는 것은 다음의 이유로 바람직하지 않다:

* 클라이언트는 자신의 코드에 줄바꿈 알고리즘(Line breaking algorithm)을 포함하게되면 더욱 복잡해지게 된다. 특히 클라이언트가 다양한 줄바꿈 알고리즘을 지원한다면, 더더욱 코드는 방대해지고 관리하기 어려워지게 된다.
* 각 알고리즘들은 사용하기에 적합한 경우가 서로 다르다. 모든 알고리즘을 사용할것이 아니라면 여러개의 줄바꿈 알고리즘을 지원할 필요 없다.
* 줄바꿈 기능이 클라이언트에 통합되어져 있다면 새로운 알고리즘을 추가하거나 기존의 알고리즘을 수정하는 것이 어려워진다.
각각의 줄바꿈 알고리즘들을 캡슐화한 클래스를 정의하여 위와 같은 문제를 피할 수 있다. 이 방식으로 캡슐화된 알고리즘을 *전략(Strategy)*이라고 한다.

![3](https://user-images.githubusercontent.com/47546079/57598140-fd79cd00-758c-11e9-98b8-8dbe231c4685.png)


Composition 클래스가 텍스트 뷰어 상에 텍스트의 줄바꿈을 관리하고 업데이트하는 역할을 한다고 가정 해보자. 줄바꿈 전략들은 Compostion 클래스에 구현되어 있지 않다. 대신에 이 Compositor 추상 클래스의 서브클래스로써 서로 분리되어 구현되어져 있다. Compositor 서브클래스들은 서로 다른 전략을 구현한다:

* **SimpleCompositor**는 한번에 한 줄씩 줄바꿈을 하는 단순한 전략을 구현한다.
* **TeXCompositor**는 전역적으로 줄바꿈이 최적화되도록 줄 바꿀 곳을 찾는 TEX알고리즘을 구현한다. 이 알고리즘은 한번에 한 문단 단위로 처리한다.
* **ArrayCompositor**는 각 행이 고정된 개수의 아이템을 갖도록 텍스트에서 줄이 바뀔 곳을 선택한다. 이 알고리즘은 예를 들어 아이콘의 집합을 한 줄로 분리할 때 유용하다.
Composition은 Compositor 객체의 참조(reference)를 관리한다. Composition은 문서 서식화를 할때마다, Compositor 객체로 책임을 넘긴다. Composition의 클라이언트는 사용하고자 하는 Compositor를 Composition에 설치함으로써 어떤 Compositor가 사용될 것인지를 지정한다.

## 활용성(Applicability)
전략 패턴은 다음과 같은 상황에서 사용한다.

* 개념적으로 비슷한 여러 클래스들이 서로 동작 방식만 다른 경우, 전략은 여러 동작 방식 중에서 한 가지를 클래스에 설정하는 방법을 제공한다.
* 알고리즘을 다르게 변형하고자 할 때 전략 패턴을 사용한다. 예를 들어, 메모리 공간과 처리 속도간에 트레이드 오프에 따른 알고리즘을 정의하는 경우가 있다. 이때 만들어지는 다양한 알고리즘들을 상속 관계로 구현하고자 할 때 전략이 사용될 수 있다.
* 클라이언트가 몰라야 할 데이터를 사용하는 알고리즘의 경우 전략 패턴이 적용될 수 있다. 알고리즘에 특정된 자료 구조와 같은 복잡한 내용의 노출을 피하기 위해 전략 패턴을 사용한다.
* 클래스가 여러 가지 동작 방식을 정의하고, 이에 따라 다중 조건문이 발생되는 경우에 전략 패턴을 적용한다. 여러 조건문을 사용하는 것보다는 관련된 분기들을 전략 클래스로 옮기는 것이 좋다.
## 구조(Structure)
![5](https://user-images.githubusercontent.com/47546079/57598143-fe126380-758c-11e9-8a91-a68d6a61be59.png)
## 참여자(Participants)
* Strategy (Compositor)
  * 제공되는 모든 알고리즘의 공통 인터페이스를 선언한다. 컨텍스트는 이 인터페이스를 사용하여 ConcreteStrategy에 정의된 알고리즘들을 호출할 수 있다.
* ConcreteStrategy (SimpleCompositor, TeXCompositor, ArrayCompositor)
  * 전략 인터페이스를 사용하여 알고리즘을 구현한다.
* Context (Composition)
  * ConcreteStrategy 객체를 통해 구성된다.
  * 전략 객체들에 대한 참조를 관리한다.
  * 전략 객체가 자료에 접근할 수 있도록 하는 인터페이스를 정의한다.
## 협력 방법(Collaborations)
* 전략 클래스와 컨텍스트 클래스는 선택된 알고리즘을 구현하기 위해 서로 상호작용한다. 컨텍스트는 알고리즘이 호출되면, 알고리즘에 필요한 모든 데이터를 전략으로 보낸다. 다른 방법으로는, 컨텍스트 자체를 인자로하여 전략 클래스로 보내기도 한다. 이를 통해 전략 클래스는 필요에 따라 컨텍스트를 호출할 수 있다.
* 컨텍스트는 자신의 클라이언트의 요청을 전략 클래스로 전달한다. 클라이언트는 일반적으로 ConcreteStrategy 객체를 생성하고 이를 컨텍스트로 전달한다. 그 후, 클라이언트는 오직 컨텍스트와 상호작용한다.
## 결과(Consequences)
전략 패턴은 다음과 같은 장점과 단점이 있습니다:

1. _관련된 알고리즘들의 집합(family)._ 전략 클래스들의 계층은 알고리즘의 집합 혹은 재사용을 위한 컨텍스트에서의 동작 방식을 정의한다. 즉, 상속은 알고리즘들의 공통된 기능을 추출하는데 유용하다.

2. _서브클래스 방식의 대안._ 상속은 다양한 알고리즘이나 동작 방식이 제공되도록 지원한다. 컨텍스트 클래스의 서브클래스를 직접적으로 만들어 다른 동작 방식을 부여할 수 있지만 이 방법은 동작 방식과 컨텍스트 사이에 결합도를 높인다. 알고리즘 구현과 컨텍스트의 구현이 섞이게되어, 컨텍스트를 이해하기 어렵고 유지보수의 난이도를 높이게된다. 결과적으로 알고리즘을 다양하게 변화시키기가 어려워진다. 알고리즘을 분리된 전략 클래스 내에 캡슐화함으로써 컨텍스트와 독립적으로 알고리즘을 쉽게 바꾸고, 이해하고, 확장할 수 있게된다.

3. _전략은 조건문을 제거한다._ 전략 패턴은 원하는 동작 방식을 선택하는 데에 있어서, 조건문 사용의 대안이 된다. 여러 동작 방식들이 한 클래스 내에 잔뜩있게되면, 적절한 동작 방식을 선택하기 위한 조건문을 사용하는것이 어려워진다. 분리된 전략 클래스로 동작 방식들을 캡슐화하여 조건문 사용을 제거할 수 있다.

4. _구현의 선택._ 전략은 같은 동작에 대한 여러 가지 구현 방식을 제공한다. 클라이언트는 메모리 공간과 처리 속도간의 트레이드 오프에 따라 자신에게 필요한 전략을 선택할 수 있다.

5. _클라이언트는 반드시 전략들에 대해 파악하고있어야 한다._ 클라이언트는 적절한 알고리즘 선택을 위해 모든 전략의 차이점을 이해해야한다. 이러한 점은 전략 패턴의 잠재적인 단점이 된다. 즉, 클라이언트가 구현 이슈에 노출될 수 있는 것이다. 그러므로 전략 패턴은 클라이언트가 동작 방식의 다양함과 관련이 있을때만 사용되어야 한다.

6. _전략과 컨텍스트간에 의사소통 오버헤드._ ConcreteStrategy 클래스들은 사소하건 중요하건 간에 모두 전략 인터페이스를 공유한다. 이러한 이유로 어떤 ConcreteStrategy 들은 인터페이스로부터 불필요한 데이터를 전달받기도 한다. 따라서 컨텍스트를 생성하고 사용하지도 않을 파라미터를 초기화하는데 불필요한 시간이 소요되게 된다. 이러한 이슈가 발생한다면, 전략과 컨텍스트간에 결합도를 높이도록해야 한다.

7. _객체가 많아진다._ 전략들이 늘어날수록 어플리케이션 내에 객체의 수가 증가하게 된다. 만약 이런 이슈로 오버헤드가 발생된다면 전략을 구현할 때, 컨텍스트들이 공유할 수 있으며 상태를 저장하지 않는(stateless)객체로 구현해야한다. 사용되지 않는 상태(residual state)는 컨텍스트에 의해 관리되는데, 컨텍스트는 이 불필요한 상태들을 전략 객체를 요청할 때 같이 전달한다. 공유되는 전략들은 실행되고 있는 중에는 상태를 관리하지 않아야한다. 플라이웨이트 패턴에서 이러한 접근 방식에 대해 좀 더 자세히 설명하고 있다.

