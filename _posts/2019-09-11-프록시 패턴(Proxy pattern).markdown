---
layout: splash
title:  "프록시 패턴(Proxy pattern)"
date:   2019-09-11 21:03:00 +0900
categories: 디자인패턴
---

## [Proxy 패턴]
## Intent
다른 객체에 대한 접근을 제어하기 위한 대리인역할을 하는 객체를 둔다

## Motivation
객체에 대한 접근을 제어하는 한 가지 이유는 우리가 실제로 특정 객체를 필요로하기 전까지 이 객체의 생성과 초기화에 대한 전체 비용을 미루기 위함이다. 그림 객체를 삽입할 수 있는 문서 에디터가 있다고 해보자. 어떤 그림 객체는 크기가 너무 커서 생성하는데 비용이 클 수도 있다. 그러나 문서를 여는 작업은 빠를수록 좋기때문에, 문서를 열때 한번에 모든 객체들을 생성하진 않을 것이다. 어쨌든 동시에 보지도 않을 문서내에 모든 그림 객체를 불러오는것은 불필요한 짓이다. 

이러한 제약들은 각각 비용이 높은 객체들이 필요할 때 생성하는 것을 제안한다. 그렇다면 문서 내에 그림이 들어갈 자리에 우린 무엇을 넣어둬야할까? 그리고 어떻게 해야 에디터의 구현을 복잡하게 하지 않기 위해 이미지는 필요할 때 생성된다는 사실을 숨길수 있을까? 이때의 최적화는 렌더링을 하고 문서를 서식화하는 작업에 영향을 미치지 않아야한다.

해답은 이미지 프록시라는 다른 객체를 사용하는 것 이다. 이 이미지 프록시는 실제 이미지의 대리인 역할을 한다. 프록시는 단지 이미지 처럼 행동하고 이미지 객체가 필요할 때 인스턴스화하는 역할을 한다.

![5](https://user-images.githubusercontent.com/47546079/57604209-9533e700-759e-11e9-82b9-778a9c8ac13f.png)

문서 에디터가 이미지를 화면에 보여주고자 프록시에게 요청을 할 때, 이미지 프록시는 진짜 이미지 객체를 생성한다. 그리고 프록시는 이미지로 일련의 요청들을 전달한다. 따라서 이미지가 생성되고나서 반드시 이미지에 대한 참조가 유지되어야 한다. 

이미지들이 분리된 파일로 저장되어 있다고 가정해보자. 이 경우 우리는 파일명을 실제 객체로의 참조로 사용할 수 있다. 프록시도 이 객체들의 크기(가로, 세로 길이)를 저장한다. 여기서 이미지의 크기는 프록시가 실제 이미지 인스턴스를 생성하지 않고도 서식자의 이미지 사이즈에 대한 요청에 응답할 수 있도록 한다. 

아래 클래스 다이어그램은 이 예시를 좀 더 자세히 보여준다.

![6](https://user-images.githubusercontent.com/47546079/57604210-9533e700-759e-11e9-841e-8d9118d3a98d.png)

문서 에디터는 추상 Graphic 클래스에 의해 정의된 인터페이스를 통해 삽입된 이미지에 접근한다. ImageProxy는 이미지에 대한 클래스로 필요할 때 생성된다. ImageProxy는 디스크 상에 이미지를 참조하기 위해 파일명을 사용한다. 파일명은 ImageProxy의 생성자의 인자로써 전달된다.

ImageProxy는 이미지의 경계 박스와 실제 이미지 인스턴스의 참조를 저장하고 있다. 이 참조는 프록시가 실제 이미지를 인스턴스화하기전까지는 유효하지 않다. 



## Applicability
프록시는 단순한 포인터보다 좀 더 정교하거나 다방면으로 객체에 참조하고자할 때 활용될 수 있다. 일반적인 프록시 패턴이 활용되는 몇몇 상황을 소개한다.

1. Remote proxy는 다른 주소 공간에 있는 객체를 위한 로컬 대리인을 제공한다.
2. Virtual proxy는 비용이 큰 객체를 필요한 순간에 생성해준다. 위의 ImageProxy가 이 프록시를 설명하는 예제가 된다.
3. Protection  proxy는 원본 객체에 접근을 제어한다. Protection proxy는 객체에 대한 접근권한이 다양할 때 유용하다. 예를 들어, KernelProxies 라는 Choices 운영체제의 프록시는 운영체제의 객체들에 대한 접근을 보호하는 기능을 한다.
4. Smart reference는 포인터의 대체물로써 객체에 접근할 때 추가적인 행동을 수행한다.


## Structure

![7](https://user-images.githubusercontent.com/47546079/57604211-9533e700-759e-11e9-9e28-9900cd30a7e2.png)


## Participants
  * **Proxy** (ImageProxy)
    * 프록시가 실제 subject에 접근할 수 있도록하는 참조를 관리한다.
    * 프록시 실제 subject의 대리인 역할을 수행하기 위해 _Subject_의 인터페이스와 동일한 인터페이스를 제공한다.
    * 실제 subject에 대한 접근을 제어하고 이를 생성하고 삭제하는 책임을 지닌다.
  * **Subject** (Graphic)
    * *Proxy*가 *RealSubject*가 사용되려는 곳 어디에서든 사용될 수 있도록 _RealSubject_와 _Proxy_를 위한 공통 인터페이스를 정의한다.
  * **RealSubject** (Image)
    * 프록시가 표현하는 실제 객체를 정의한다.


## Related Patterns
Decorator 패턴: 데코레이터는 프록시를 구현하는 것과 유사하지만 각각은 사용 목적이 서로 다르다. *데코레이터는 한 객체에 한 가지 혹은 그 이상의 책임을 추가할때 사용되며, 반면에 프록시는 한 객체에 대한 접근을 제어하고자 할 때 사용된다.* 프록시는 데코레이터처럼 구현방법이 다양하다. Protection proxy는 데코레이터와 거의 일치하게 구현되어진다. 반면에 remote proxy는 실제 객체에 대한 직접적인 참조를 포함하지 않으며 대신 간접적으로 접근을 한다. Virtual 프록시는 파일명과 같은 간접 참조와 함께 시작하지만 결국 직접적인 참조를 획득하고 사용한다.
***