---
layout: splash
title:  "[모던자바인액션] 스트림 활용"
date:   2019-10-06 23:27:00 +0900
categories: 자바
---

## 필터링
1. Predicate 필터링
    - 스트림 인터페이스에서 제공하는 filter메서드는 *predicate*를 인수로 받아서, *predicate*과 일치하는 요소들을 스트림으로 리턴한다.
    ```java
    List<Dish> vegetarianMenu = menu.stream()
                                    .filter(Dish::isVegetarian)
                                    .collect(toList());
    ```
2. 고유 요소 필터링
    - 스트림은 unique 요소들만 포함하는 스트림을 반환하는 `distinct` 메서드를 제공한다.
    ```java
    List<Integer> numbers = Arrays.asList(1, 2, 1, 2, 3, 2, 4);
    numbers.stream()
            .filter(i -> i % 2 == 0) // 2, 2, 4
            .distinct() // 2, 4
            .forEach(System.out::println);
    ```

## 스트림 슬라이싱
1. Predicate를 이용한 슬라이싱
    - `takeWhile`
        ```java
        /**
        * Returns, if this stream is ordered, a stream consisting of the remaining
        * elements of this stream after dropping the longest prefix of elements
        * that match the given predicate.  Otherwise returns, if this stream is
        * unordered, a stream consisting of the remaining elements of this stream
        * after dropping a subset of elements that match the given predicate.
        *
        * <p>If this stream is ordered then the longest prefix is a contiguous
        * sequence of elements of this stream that match the given predicate.  The
        * first element of the sequence is the first element of this stream, and
        * the element immediately following the last element of the sequence does
        * not match the given predicate.
        *
        * <p>If this stream is unordered, and some (but not all) elements of this
        * stream match the given predicate, then the behavior of this operation is
        * nondeterministic; it is free to drop any subset of matching elements
        * (which includes the empty set).
        *
        * <p>Independent of whether this stream is ordered or unordered if all
        * elements of this stream match the given predicate then this operation
        * drops all elements (the result is an empty stream), or if no elements of
        * the stream match the given predicate then no elements are dropped (the
        * result is the same as the input).
        *
        * <p>This is a <a href="package-summary.html#StreamOps">stateful
        * intermediate operation</a>.
        *
        * @implSpec
        * The default implementation obtains the {@link #spliterator() spliterator}
        * of this stream, wraps that spliterator so as to support the semantics
        * of this operation on traversal, and returns a new stream associated with
        * the wrapped spliterator.  The returned stream preserves the execution
        * characteristics of this stream (namely parallel or sequential execution
        * as per {@link #isParallel()}) but the wrapped spliterator may choose to
        * not support splitting.  When the returned stream is closed, the close
        * handlers for both the returned and this stream are invoked.
        *
        * @apiNote
        * While {@code dropWhile()} is generally a cheap operation on sequential
        * stream pipelines, it can be quite expensive on ordered parallel
        * pipelines, since the operation is constrained to return not just any
        * valid prefix, but the longest prefix of elements in the encounter order.
        * Using an unordered stream source (such as {@link #generate(Supplier)}) or
        * removing the ordering constraint with {@link #unordered()} may result in
        * significant speedups of {@code dropWhile()} in parallel pipelines, if the
        * semantics of your situation permit.  If consistency with encounter order
        * is required, and you are experiencing poor performance or memory
        * utilization with {@code dropWhile()} in parallel pipelines, switching to
        * sequential execution with {@link #sequential()} may improve performance.
        *
        * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
        *                  <a href="package-summary.html#Statelessness">stateless</a>
        *                  predicate to apply to elements to determine the longest
        *                  prefix of elements.
        * @return the new stream
        * @since 9
        */
        default Stream<T> dropWhile(Predicate<? super T> predicate) {
            Objects.requireNonNull(predicate);
            // Reuses the unordered spliterator, which, when encounter is present,
            // is safe to use as long as it configured not to split
            return StreamSupport.stream(
                    new WhileOps.UnorderedWhileSpliterator.OfRef.Dropping<>(spliterator(), true, predicate),
                    isParallel()).onClose(this::close);
        }
        ```

    - `dropWhile`
        ```java
        /**
        * Returns, if this stream is ordered, a stream consisting of the remaining
        * elements of this stream after dropping the longest prefix of elements
        * that match the given predicate.  Otherwise returns, if this stream is
        * unordered, a stream consisting of the remaining elements of this stream
        * after dropping a subset of elements that match the given predicate.
        *
        * <p>If this stream is ordered then the longest prefix is a contiguous
        * sequence of elements of this stream that match the given predicate.  The
        * first element of the sequence is the first element of this stream, and
        * the element immediately following the last element of the sequence does
        * not match the given predicate.
        *
        * <p>If this stream is unordered, and some (but not all) elements of this
        * stream match the given predicate, then the behavior of this operation is
        * nondeterministic; it is free to drop any subset of matching elements
        * (which includes the empty set).
        *
        * <p>Independent of whether this stream is ordered or unordered if all
        * elements of this stream match the given predicate then this operation
        * drops all elements (the result is an empty stream), or if no elements of
        * the stream match the given predicate then no elements are dropped (the
        * result is the same as the input).
        *
        * <p>This is a <a href="package-summary.html#StreamOps">stateful
        * intermediate operation</a>.
        *
        * @implSpec
        * The default implementation obtains the {@link #spliterator() spliterator}
        * of this stream, wraps that spliterator so as to support the semantics
        * of this operation on traversal, and returns a new stream associated with
        * the wrapped spliterator.  The returned stream preserves the execution
        * characteristics of this stream (namely parallel or sequential execution
        * as per {@link #isParallel()}) but the wrapped spliterator may choose to
        * not support splitting.  When the returned stream is closed, the close
        * handlers for both the returned and this stream are invoked.
        *
        * @apiNote
        * While {@code dropWhile()} is generally a cheap operation on sequential
        * stream pipelines, it can be quite expensive on ordered parallel
        * pipelines, since the operation is constrained to return not just any
        * valid prefix, but the longest prefix of elements in the encounter order.
        * Using an unordered stream source (such as {@link #generate(Supplier)}) or
        * removing the ordering constraint with {@link #unordered()} may result in
        * significant speedups of {@code dropWhile()} in parallel pipelines, if the
        * semantics of your situation permit.  If consistency with encounter order
        * is required, and you are experiencing poor performance or memory
        * utilization with {@code dropWhile()} in parallel pipelines, switching to
        * sequential execution with {@link #sequential()} may improve performance.
        *
        * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
        *                  <a href="package-summary.html#Statelessness">stateless</a>
        *                  predicate to apply to elements to determine the longest
        *                  prefix of elements.
        * @return the new stream
        * @since 9
        */
        default Stream<T> dropWhile(Predicate<? super T> predicate) {
            Objects.requireNonNull(predicate);
            // Reuses the unordered spliterator, which, when encounter is present,
            // is safe to use as long as it configured not to split
            return StreamSupport.stream(
                    new WhileOps.UnorderedWhileSpliterator.OfRef.Dropping<>(spliterator(), true, predicate),
                    isParallel()).onClose(this::close);
        }
        ```

2. 스트림 축소
    - 스트림은 `limit(n)` 메서드를 제공하여, 주어진 사이즈 이하의 스트림을 리턴하도록한다.
    ```java
    /* Stream.java */
    /**
     * Returns a stream consisting of the elements of this stream, truncated
     * to be no longer than {@code maxSize} in length.
     *
     * <p>This is a <a href="package-summary.html#StreamOps">short-circuiting
     * stateful intermediate operation</a>.
     *
     * @apiNote
     * While {@code limit()} is generally a cheap operation on sequential
     * stream pipelines, it can be quite expensive on ordered parallel pipelines,
     * especially for large values of {@code maxSize}, since {@code limit(n)}
     * is constrained to return not just any <em>n</em> elements, but the
     * <em>first n</em> elements in the encounter order.  Using an unordered
     * stream source (such as {@link #generate(Supplier)}) or removing the
     * ordering constraint with {@link #unordered()} may result in significant
     * speedups of {@code limit()} in parallel pipelines, if the semantics of
     * your situation permit.  If consistency with encounter order is required,
     * and you are experiencing poor performance or memory utilization with
     * {@code limit()} in parallel pipelines, switching to sequential execution
     * with {@link #sequential()} may improve performance.
     *
     * @param maxSize the number of elements the stream should be limited to
     * @return the new stream
     * @throws IllegalArgumentException if {@code maxSize} is negative
     */
    Stream<T> limit(long maxSize);

    /* ReferencePipeline.java*/
    @Override
    public final Stream<P_OUT> limit(long maxSize) {
        if (maxSize < 0)
            throw new IllegalArgumentException(Long.toString(maxSize));
        return SliceOps.makeRef(this, 0, maxSize);
    }
    ```

3. 스킵
    - 스트림은 `skip(n)` 메서드를 제공하여, 처음 n개의 요소를 건너뛰고 처리된 스트림을 리턴하도록한다. 
    ```java
    /* Stream.java */
    /**
     * Returns a stream consisting of the remaining elements of this stream
     * after discarding the first {@code n} elements of the stream.
     * If this stream contains fewer than {@code n} elements then an
     * empty stream will be returned.
     *
     * <p>This is a <a href="package-summary.html#StreamOps">stateful
     * intermediate operation</a>.
     *
     * @apiNote
     * While {@code skip()} is generally a cheap operation on sequential
     * stream pipelines, it can be quite expensive on ordered parallel pipelines,
     * especially for large values of {@code n}, since {@code skip(n)}
     * is constrained to skip not just any <em>n</em> elements, but the
     * <em>first n</em> elements in the encounter order.  Using an unordered
     * stream source (such as {@link #generate(Supplier)}) or removing the
     * ordering constraint with {@link #unordered()} may result in significant
     * speedups of {@code skip()} in parallel pipelines, if the semantics of
     * your situation permit.  If consistency with encounter order is required,
     * and you are experiencing poor performance or memory utilization with
     * {@code skip()} in parallel pipelines, switching to sequential execution
     * with {@link #sequential()} may improve performance.
     *
     * @param n the number of leading elements to skip
     * @return the new stream
     * @throws IllegalArgumentException if {@code n} is negative
     */
    Stream<T> skip(long n);

    /* ReferencePipeline.java*/
    @Override
    public final Stream<P_OUT> skip(long n) {
        if (n < 0)
            throw new IllegalArgumentException(Long.toString(n));
        if (n == 0)
            return this;
        else
            return SliceOps.makeRef(this, n, -1);
    }
    ```

## 매핑
